# MNIST

> MNIST问题（手写数字识别问题） ， 被视作机器学习领域的**Hello, World**
>
> MNIST问题的目标是**将手绘数字图像分类到其对应的数字**。
> 比如 图像 <img src="/Users/as/Desktop/md/MNIST.assets/image-20250417082702981.png" alt="image-20250417082702981" style="zoom:5%;" />  ，需要被识别为数字0。
>
> 我们将会 从0手撸一个神经网络模型(不使用深度学习框架) ，来解决MNIST问题。
> 该模型将会有一个卷积层，一个激活函数层，一个池化层，一个全连接层



---

## 大纲

* 模型如何通过计算**识别**出一个图片是数字几

  * **卷积层**：通过矩阵计算来扫描数据，从而得出特征 ⬇️ 
  * **激活函数层**：利用各种激活函数，进一步提取数据特征；提升泛化能力，防止过拟合。⬇️
  * **池化层**：对数据进行降维，降低计算难度；提升泛化能力。⬇️
    （泛化能力：模型能正确处理 越多的未知数据，则视为泛化能力越好；反之 则视为泛化能力差）
  * **全连接层**：对上一层的所有数据进行加权组合（矩阵运算），再输出结果 ✅

  

* 如何训练出这个模型

  * 评估计算结果：通过**损失函数**来量化模型的计算结果

  * 寻找数学关系：建立**量化结果**和**权重矩阵**之间的数学关系（梯度/导数）

  * 进行优化：基于梯度，再使用**优化器**去调节权重矩阵

    


---



## 如何识别

模型怎么知道是这个数字是几？



### 卷积层

通过矩阵计算来扫描数据，从而得出特征

* 怎么计算？ 

  * 大小相同的矩阵 相同位置的元素相乘，再求和。

* 用什么矩阵进行计算？

  *  用 权重矩阵 和 输入矩阵中与卷积核大小相同的局部区域 进行计算。权重矩阵会滑动遍历输入矩阵

* 什么叫**扫描数据**？

  *  因为上述提到计算的时候 需要用 **大小相同 ** 的矩阵进行计算。但实际上权重矩阵和输入矩阵的大小并不相通。
    所以相当于用拿着权重矩阵 依次去 **扫描** 输入矩阵中同等大小的矩阵，得出特征。

    ![286958479_3_20240806073749800](/Users/as/Desktop/md/MNIST.assets/286958479_3_20240806073749800.gif) 

  * 举个例子  

    

  
  $$
  图像（数字7） 的 数据矩阵 \begin{bmatrix}
  1 & 1 & 1 & 0 & 0 \\
  0 & 0 & 1 & 0 & 0 \\
  0 & 0 & 1 & 0 & 0 \\
  0 & 0 & 1 & 0 & 0 \\
  0 & 0 & 1 & 0 & 0 
  \end{bmatrix}  
  \\
  \\
  权重矩阵\begin{bmatrix}
  1 & 1 & 1 \\
  0 & 0 & 0 \\
  -1 & -1 & -1 
  \end{bmatrix} 
  \\(这个权重矩阵可以 "读取" 到图像中的横向信息)
  $$
  

  计算过程
  <img src="/Users/as/Desktop/md/MNIST.assets/image-20250418185130695.png" alt="image-20250418185130695" style="zoom:15%;" /><img src="/Users/as/Desktop/md/MNIST.assets/image-20250418185156238.png" alt="image-20250418185156238" style="zoom:15%;" /><img src="/Users/as/Desktop/md/MNIST.assets/image-20250418185227440.png" alt="image-20250418185227440" style="zoom:15%;" />
  <img src="/Users/as/Desktop/md/MNIST.assets/image-20250418185331762.png" alt="image-20250418185331762" style="zoom:15%;" /><img src="/Users/as/Desktop/md/MNIST.assets/image-20250418185405897.png" alt="image-20250418185405897" style="zoom:15%;" />(剩下的按照规律继续计算)

  最终得出

  * 图像（数字7）在经过权重矩阵的计算之后，得到的结果是
    $$
    数字7的特征矩阵\begin{bmatrix}
    3 & 2 & 1 \\
    1 & 1 & 1 \\
    1 & 1 & 1 
    \end{bmatrix}
    \\
    ..\\..
    \\
    根据同样的计算，如果是数字1的话，经过计算 会得到\\
    数字1的特征矩阵\begin{bmatrix}
    1 & 1 & 1 \\
    1 & 1 & 1 \\
    1 & 1 & 1 
    \end{bmatrix}
    
    \\
    \\
    或许能get到一点，提取特征这个概念了？\\
    我们上述举例的权重矩阵是提取横向特征的。\\ \\
    当遇到横向的笔画时，能够把这个笔画的信息放大。\\
    当遇到纵向的笔画时，将抑制这个纵向的笔画信息。
    $$
    

> 至此 ，卷积层的计算就结束了。得到了一个特征矩阵。
> 这个特征矩阵是卷积层中 权重矩阵通过矩阵计算得出的一个 带有***特征*** 的矩阵



### 激活函数层

利用各种激活函数，引入非线性变换，进一步提取数据特征

* 引入非线形变换 是什么意思？
  * 简单的理解就是 ，让模型更能处理复杂的数据。
  * 先理解 线性变化  ，输入与输出之间 ， 一一对应，一个输入必定会产生一个唯一的输出
    非线性变化 则 ，输入与输出的关系变得复杂，非线性，意味着 可能多个x对应一个y
* 如何利用激活函数？
  * 将上一层输出的矩阵 ，作为激活函数层的输入矩阵，然后经过激活函数计算即可
  * 激活函数通常是逐元素地应用于输入矩阵的每个元素
* 用什么激活函数？
  * 激活函数有很多种。一般会根据问题的不同，选择不同的激活函数。



举个例子
$$
输入矩阵A:\begin{bmatrix}
3 & 2 & 1 \\
1 & 1 & 1 \\
-1 & -1 & -1 
\end{bmatrix}
\\
\\
激活函数使用 ReLU函数\\ReLU : f(x)=max(0,x)
\\
\\
ReLU(A) =\begin{bmatrix}
3 & 2 & 1 \\
1 & 1 & 1 \\
0 & 0 & 0
\end{bmatrix}
$$


> 至此，激活函数层的运算结束了。以上一层的输出作为输入，然后处理之后 得到了一个新的特征矩阵。
> 激活函数通过引入非线性变换，使得 神经网络能够选择性地 **增强那些对学习复杂模式有用的信息，并抑制无关信息**，
> 来得到一个更为**"正确"**的特征矩阵





### 全连接层

对上一层的数据进行加权求和，得到你想要的输出数据

* 加权求和

  * 输出的每个维度是**独立计算**的。
  * 每个输出维度都有自己**专属的一组权重**。
  * 这些独立的权重组 共同组成了 我们看到的那个大的权重矩阵

* 先整体回顾一下 目前的处境

  > 模型读取到一个手写数字图片
  >  -> 图片在代码里被读取为了一个数据矩阵
  >  -> **卷积层**处理数据矩阵，提取特征，得到 特征矩阵1
  >  -> **激活函数层**处理特征矩阵1，进一步提取特征，得到了特征矩阵2
  >
  > 
  >
  > 现在我们手头有一个特征矩阵2，
  > 我们最终的目的是 **判断图片是数字几**
  >
  > > 代码将会输出的是，这个图片是**数字1,2,3,,,9的 ‘得分’** ， 总共有10个得分
  >
  > 
  >
  > 所以 我们的这个全连接层需要做的事情是 ，根据特征矩阵2 得到 图片是**数字0,1,2,3,,,9的得分**(10个值，也可以称为10个维度)
  > **Q：怎么做呢？**
  > **A：加权求和！**

  

*  如何得到 **图片是数字0 的概率**？
  $$
  特征矩阵B=\begin{bmatrix}
  3 & 2 & 1 \\
  1 & 1 & 1 \\
  0 & 0 & 0
  \end{bmatrix}
  \\
  先展平得到 矩阵C = \begin{bmatrix}
  3 & 2 & 1 & 1 & 1 & 1 & 0 & 0 & 0
  \end{bmatrix}
  \\\\
  计算 数字0 对应的权重组 ，
  W0 = \begin{bmatrix}
  0.01 \\
  0.01 \\
  0.01 \\
  0.01 \\
  0.02 \\
  0 \\
  0 \\
  0 \\
  0.02 \\
  \end{bmatrix}
  \\\\
  矩阵C * 矩阵W0 = 3*0.01 + 2*0.01 + 1*0.01 + 1*0.01 + 1*0.02 + 1*0 + 0*0 + 0*0 + 0*0.02 = 0.09
  $$

  > 我们利用 数字0对应的权重组 W0，得到了 这个图片可能是数字0的得分  -- 0.09

  

  针对其他数字，计算同上（需要注意的是，不同的数字都会有一个不同的权重组。）
  这十个数字的权重组 ，组成了 全连接层的权重矩阵

  

  > 至此 我们将会得到 这个图片 对应在十个数字上的得分 。
  > 比如从数字0到数字9的得分分别是 [0.09 , 0.02 , 0.05 , 0.09 , 0.12 , 0.04 , 0.05 , 0.91 , 0.06 , 0.08]
  >
  > 该图片在数字7上的得分最高，则 模型会认为这个数字就是 7




---



## 如何训练

训练模型本质上是一个反馈调节的过程。
通过持续得进行计算，评估计算结果，从而反馈调节计算过程中的参数



### 评估计算结果

评估计算结果的思路其实很直接。
我们拥有一个计算出来的结果，并且拥有一个正确的结果，则只需要比较这两个结果之间的差异就行了。
**至于量化结果** ，根据不同类型的深度学习问题，有不同的量化方式（损失函数）

* 损失函数：评估模型计算结果的概率矩阵 和 真实结果的概率矩阵的 **差值**

  

举个例子
$$
模型-预测的概率矩阵（图片可能是数字0,1,2,3...9的概率）
\\\
P = \begin{bmatrix}
0.09 & 0.02 & 0.05 & 0.09 & 0.12 & 0.04 & 0.05 & 0.91 & 0.06 & 0.08
\end{bmatrix}
\\\\\\
图片7-真实的概率矩阵 
\\\
T =  \begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0
\end{bmatrix}
\\\
矩阵T的理解：图片7是数字0的概率是0；图片7是数字1的概率是0...图片7是数字7的概率是1...
\\\\\\
损失函数有很多种，我们这里选择使用均方差来作为模型的损失函数。
\\\
Loss = \begin{bmatrix}
(T1 - P1)² & (T2 - P2)² & (T3 - P3)² & ... & (T10 - P10)²
\end{bmatrix}
$$

> 损失函数得到的值，主要是用来评估模型的好坏。 Loss可能并不会直接参与到后续的优化环节。
> 直接参与优化环节的数据是 梯度。在下一部分会使用到。



### 寻找数学关系

在知晓了预测结果和正确结果之后，如何去反馈调节权重矩阵的参数 -- **求导**
通过求损失函数相对于模型参数的导数，从而知晓这个模型参数应该怎么去调整。

* 这里是纯数学问题的领域了。不做过多论证。（例子部分 和 后续优化器环节一并举例）



### 进行优化

优化环节，会倒着从最后面的层开始使用梯度优化参数，
然后结合该层的矩阵信息 形成新的梯度，再依次往上长传递。

举一个复杂的例子
$$
先根据P和T 得到初始梯度 gradient = \begin{bmatrix}
P1-T1 & P2-T2 & ... & P10-T10
\end{bmatrix}\\\ 记做 [g1,g2,g3,,,g10]
\\\\\\
回顾一下，最后一层（全连接层）\\\
W = \begin{bmatrix}
W(0,0) & W(0,1) & ... & W(0,10)\\\
W(1,0) & W(1,1) & ... & W(1,10)\\\
...\\\
W(9,0) & W(9,1) & ... & W(9,10)
\end{bmatrix}\\\
全连接层的输入矩阵C = \begin{bmatrix}
C1 & C2 & C3 & ... & C9
\end{bmatrix}
\\\\
\\\
则 新的全连接层权重矩阵是 
W = \begin{bmatrix}
W(0,0)-C1*g1 & W(0,1)-C2*g1 & \cdots & W(0,9)-C10*g1 \\
W(1,0)-C2*g2 & W(1,1)-C2*g2 & \cdots & W(1,9)-C10*g2 \\
\vdots & \vdots & \ddots & \vdots \\
W(9,0)-C10*g10 & W(9,1)-C2*g10 & \cdots & W(9,9)-C10*g10
\end{bmatrix}
$$
















